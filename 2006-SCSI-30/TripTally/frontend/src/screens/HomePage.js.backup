import React, { useEffect, useState, useRef } from "react";
import { View, Text, TouchableOpacity, ActivityIndicator, Dimensions, Modal, Alert } from "react-native";
import MapView, { PROVIDER_GOOGLE, Marker, Polyline } from "react-native-maps";
import * as Location from "expo-location";
import Ionicons from "@expo/vector-icons/Ionicons";
import polyline from "@mapbox/polyline";
import { useRoute, useFocusEffect } from "@react-navigation/native";
import useThemedStyles from "../hooks/useThemedStyles";
import { BASE_URL } from "../config/keys"; 
import { apiGet, apiDelete } from '../services/api';
import { useAuth } from '../context/AuthContext';

const { height } = Dimensions.get("window");

// Keep BASE_URL authoritative.
const API_BASE = BASE_URL;
console.log("API_BASE =", API_BASE);

export default function HomePage({ navigation, route }) {
  const { user } = useAuth();
  const mapRef = useRef(null);
  const routeNav = useRoute();
  const [trafficAlerts, setTrafficAlerts] = useState([]);
  const [selectedAlert, setSelectedAlert] = useState(null);
  const [showModal, setShowModal] = useState(false);
  const [userLocations, setUserLocations] = useState({ home: null, work: null });

const { height } = Dimensions.get("window");

// Keep BASE_URL authoritative.
const API_BASE = BASE_URL;
console.log("API_BASE =", API_BASE);

export default function HomePage({ navigation, route }) {
  const { user } = useAuth();
  const mapRef = useRef(null);
  const routeNav = useRoute();
  const [trafficAlerts, setTrafficAlerts] = useState([]);
  const [selectedAlert, setSelectedAlert] = useState(null);
  const [showModal, setShowModal] = useState(false);
  const [userLocations, setUserLocations] = useState({ home: null, work: null });

  const { styles, theme } = useThemedStyles(({ colors }) => ({
    root: { flex: 1 },
    warningBtn: {
      position: "absolute",
      right: 28,
      backgroundColor: colors.card,
      borderRadius: 30,
      width: 52,
      height: 52,
      alignItems: "center",
      justifyContent: "center",
      elevation: 7,
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: colors.mode === "dark" ? 0.4 : 0.16,
      shadowRadius: 10,
      borderWidth: 3,
      borderColor: colors.border,
    },
    bottomSheet: {
      position: "absolute",
      left: 12,
      right: 12,
      bottom: 20,
      backgroundColor: colors.card,
      padding: 12,
      borderRadius: 18,
      borderWidth: 0.5,
      borderColor: colors.border,
    },
    search: { backgroundColor: colors.pillAlt, padding: 14, borderRadius: 12 },
    searchText: { color: colors.muted, fontWeight: "600" },
  }));

  const [origin, setOrigin] = useState(null);           // live user location
  const [destination, setDestination] = useState(null); // { name, latitude, longitude }
  const [routeCoords, setRouteCoords] = useState([]);   // decoded polyline
  const [distance, setDistance] = useState(null);
  const [duration, setDuration] = useState(null);
  const [loadingRoute, setLoadingRoute] = useState(false);

  // Map readiness + pending fit (ensures fitToCoordinates runs right after layout)
  const [mapReady, setMapReady] = useState(false);
  const pendingFitRef = useRef(null);

  // Throttle + in-flight guard
  const lastFetchRef = useRef(0);
  const inFlightRef = useRef(false);

  // 1) Permission + current location + watch updates (use last-known first for instant origin)
  useEffect(() => {
    let watcher = null;
    (async () => {
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== "granted") {
        Alert.alert("Location", "Location permission not granted");
        return;
      }

      // ⚡️ instant cached location if available
      const last = await Location.getLastKnownPositionAsync();
      if (last?.coords) {
        const quick = { latitude: last.coords.latitude, longitude: last.coords.longitude };
        setOrigin(quick);
        if (!destination) {
          mapRef.current?.animateCamera({ center: quick, zoom: 16 }, { duration: 300 });
        }
      }

      // then get a fresh fix and start watching
      const loc = await Location.getCurrentPositionAsync({});
      const start = { latitude: loc.coords.latitude, longitude: loc.coords.longitude };
      setOrigin(start);

      watcher = await Location.watchPositionAsync(
        { accuracy: Location.Accuracy.Balanced, distanceInterval: 5, timeInterval: 3000 },
        (pos) => {
          const next = { latitude: pos.coords.latitude, longitude: pos.coords.longitude };
          setOrigin(next);
          if (!destination) {
            mapRef.current?.animateCamera({ center: next, zoom: 16 }, { duration: 500 });
          }
        }
      );
    })();

    return () => watcher?.remove?.();
  }, [destination]);

  // 2) Pick up destination from navigation params on focus
  useFocusEffect(
    React.useCallback(() => {
      const dest = routeNav.params?.destination;
      if (dest?.latitude && dest?.longitude) setDestination(dest);
    }, [routeNav.params?.destination])
  );

  // Shared directions fetcher (instant on selection, lightly throttled while moving)
  const fetchDirections = async (o, d) => {
    if (!o || !d) return;
    if (inFlightRef.current) return;

    inFlightRef.current = true;
    setLoadingRoute(true);

    try {
      const qs = new URLSearchParams({
        origin: `${o.latitude},${o.longitude}`,
        destination: `${d.latitude},${d.longitude}`,
        mode: "driving",
        alternatives: "false",
      });
      const url = `${API_BASE}/maps/directions?${qs.toString()}`;

      console.time?.("directions");
      const res = await fetch(url, { headers: { Accept: "application/json" } });
      if (!res.ok) {
        const text = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${res.statusText} – ${text}`);
      }
      const data = await res.json();
      console.timeEnd?.("directions");

      let coords = [];
      if (Array.isArray(data.coordinates)) {
        coords = data.coordinates;
      } else {
        const encoded =
          data.overview_polyline?.points ||
          data.overview_polyline ||
          data.polyline;
        if (!encoded) throw new Error("No route polyline in response.");
        const pts = polyline.decode(encoded);
        coords = pts.map(([lat, lng]) => ({ latitude: lat, longitude: lng }));
      }

      setRouteCoords(coords);
      setDistance(data.distance_meters ?? data.distance ?? null);
      setDuration(data.duration_seconds ?? data.duration ?? null);

      const doFit = () => {
        if (coords.length > 1 && mapRef.current?.fitToCoordinates) {
          mapRef.current.fitToCoordinates(coords, {
            edgePadding: { top: 80, right: 80, bottom: 220, left: 80 },
            animated: true,
          });
        }
      };
      if (mapReady) setTimeout(doFit, 0);
      else pendingFitRef.current = coords;

      lastFetchRef.current = Date.now();
    } catch (err) {
      console.log("Route fetch failed:", err);
      Alert.alert("Route", String(err.message || err));
    } finally {
      inFlightRef.current = false;
      setLoadingRoute(false);
    }
  };

  // 3a) Fetch immediately when user sets a destination
  useEffect(() => {
    if (destination && origin) {
      fetchDirections(origin, destination);
    }
  }, [destination, origin]); // immediate on change

  // 3b) Also refresh on origin updates with a light throttle (2s) while moving
  useEffect(() => {
    if (!origin || !destination) return;
    const now = Date.now();
    if (now - lastFetchRef.current >= 2000) {
      fetchDirections(origin, destination);
    }
  }, [origin, destination]);

  if (!origin) {
    return (
      <View style={[styles.root, { justifyContent: "center", alignItems: "center" }]}>
        <ActivityIndicator />
        <Text style={{ color: theme.colors.text }}>Loading map…</Text>
      </View>
    );
  }

  return (
    <View style={styles.root}>
      <MapView
        ref={mapRef}
        provider={PROVIDER_GOOGLE}
        style={{ flex: 1 }}
        initialRegion={{
          latitude: origin.latitude,
          longitude: origin.longitude,
          latitudeDelta: 0.05,
          longitudeDelta: 0.05,
        }}
      >
        {/* Traffic Alert Markers */}
        {trafficAlerts.map((alert) => (
          <Marker
            key={alert.id}
            coordinate={{
              latitude: alert.latitude,
              longitude: alert.longitude,
            }}
            title={alert.obstruction_type}
            description={alert.location_name || 'Reported incident'}
            onPress={() => handleMarkerPress(alert)}
          >
            <View style={[styles.markerContainer, { 
              backgroundColor: getIncidentColor(alert.obstruction_type) 
            }]}>
              <Ionicons 
                name={getIncidentIcon(alert.obstruction_type)} 
                size={20} 
                color="white" 
              />
            </View>
          </Marker>
        ))}

        {/* Home Location Marker */}
        {userLocations.home && (
          <Marker
            coordinate={{
              latitude: userLocations.home.latitude,
              longitude: userLocations.home.longitude,
            }}
            title="Home"
            description={userLocations.home.address}
            onPress={handleHomePress}
          >
            <View style={[styles.markerContainer, { backgroundColor: '#3B82F6', borderColor: '#60A5FA' }]}>
              <Ionicons name="home" size={20} color="white" />
            </View>
          </Marker>
        )}

        {/* Work Location Marker */}
        {userLocations.work && (
          <Marker
            coordinate={{
              latitude: userLocations.work.latitude,
              longitude: userLocations.work.longitude,
            }}
            title="Work"
            description={userLocations.work.address}
            onPress={handleWorkPress}
          >
            <View style={[styles.markerContainer, { backgroundColor: '#8B5CF6', borderColor: '#A78BFA' }]}>
              <Ionicons name="briefcase" size={20} color="white" />
            </View>
          </Marker>
        showsUserLocation
        showsMyLocationButton
        onMapReady={() => {
          setMapReady(true);
          if (pendingFitRef.current && mapRef.current?.fitToCoordinates) {
            const coords = pendingFitRef.current;
            pendingFitRef.current = null;
            setTimeout(() => {
              mapRef.current.fitToCoordinates(coords, {
                edgePadding: { top: 80, right: 80, bottom: 220, left: 80 },
                animated: true,
              });
            }, 0);
          }
        }}
      >
        {destination && (
          <Marker
            coordinate={{ latitude: destination.latitude, longitude: destination.longitude }}
            title={destination.name || "Destination"}
          />
        )}

        {routeCoords.length > 0 && (
          <Polyline coordinates={routeCoords} strokeWidth={5} />
        )}
      </MapView>

      <TouchableOpacity
        style={[styles.warningBtn, { bottom: height * 0.17 }]}
        onPress={() => navigation.navigate("ReportRoadIncident")}
      >
        <Ionicons name="warning" size={30} />
      </TouchableOpacity>

      <View style={styles.bottomSheet}>
        <TouchableOpacity onPress={() => navigation.navigate("Search")}>
          <View style={styles.search}>
            <Text style={styles.searchText}>
              {loadingRoute ? "Finding route…" : destination?.name || "Where to?"}
            </Text>
          </View>
        </TouchableOpacity>
        <View style={styles.quickRow}>
          <TouchableOpacity style={styles.quickBtn} onPress={handleHomePress}>
            <Ionicons name="home" size={18} color={theme.colors.text} />
            <Text style={styles.quickTxt}>Home</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.quickBtn} onPress={handleWorkPress}>
            <Ionicons name="briefcase" size={18} color={theme.colors.text} />
            <Text style={styles.quickTxt}>Work</Text>
          </TouchableOpacity>
          {/* <TouchableOpacity style={styles.quickBtn}>
            <Ionicons name="add" size={18} color={theme.colors.text} />
            <Text style={styles.quickTxt}>New</Text>
          </TouchableOpacity> */}
        </View>
      </View>

      {/* Incident Details Modal */}
      <Modal
        visible={showModal}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowModal(false)}
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            {selectedAlert && (
              <>
                <View style={styles.modalHeader}>
                  <View style={[styles.modalIconContainer, { 
                    backgroundColor: getIncidentColor(selectedAlert.obstruction_type) 
                  }]}>
                    <Ionicons 
                      name={getIncidentIcon(selectedAlert.obstruction_type)} 
                      size={26} 
                      color="white" 
                    />
                  </View>
                  <Text style={styles.modalTitle}>{selectedAlert.obstruction_type}</Text>
                </View>

                <View style={styles.modalInfo}>
                  {selectedAlert.location_name && (
                    <>
                      <Text style={styles.modalLabel}>Location</Text>
                      <Text style={styles.modalValue}>{selectedAlert.location_name}</Text>
                    </>
                  )}
                  
                  <Text style={styles.modalLabel}>Coordinates</Text>
                  <Text style={styles.modalValue}>
                    {selectedAlert.latitude.toFixed(6)}, {selectedAlert.longitude.toFixed(6)}
                  </Text>
                  
                  {selectedAlert.created_at && (
                    <>
                      <Text style={styles.modalLabel}>Reported</Text>
                      <Text style={styles.modalValue}>
                        {new Date(selectedAlert.created_at).toLocaleString()}
                      </Text>
                    </>
                  )}
                </View>

                <View style={styles.modalButtons}>
                  <TouchableOpacity 
                    style={[styles.modalButton, styles.resolveButton]}
                    onPress={handleResolveIncident}
                  >
                    <Text style={styles.buttonText}>Resolve</Text>
                  </TouchableOpacity>
                  
                  <TouchableOpacity 
                    style={[styles.modalButton, styles.cancelButton]}
                    onPress={() => setShowModal(false)}
                  >
                    <Text style={styles.buttonText}>Cancel</Text>
                  </TouchableOpacity>
                </View>
              </>
            )}
          </View>
        </View>
      </Modal>
    </View>
  );
}
